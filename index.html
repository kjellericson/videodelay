<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Display Webcam Stream</title>

    <style>
        #pausebutton,
        #replaybutton {
            font-size: 2em;
            border-radius: 5%;
        }

        #timediff {
            font-size: 1.5em;
            color: black;
            font-weight: bold;
            background-color: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(5px);
            padding: 5px 10px;
            border-radius: 50%;
        }

        #fullscreenbutton {
            font-size: 2em;
            border-radius: 5%;
            position: absolute;
            top: 10px;
            right: 10px;
        }

        #container.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 9999;
            background-color: black;
        }

        #container.fullscreen #videoElement {
            width: 100vw;
            height: 100vh;
            object-fit: contain;
        }

        #container.fullscreen #settings {
            display: none;
        }
    </style>
</head>

<body onload="init()">
    <h1>Video delay</h1>
    <div id="container">
        <button id="fullscreenbutton" onclick="toggleFullscreen()">Fullscreen</button>
        <div id="settings">
            <div style="display: grid; grid-template-columns: auto  auto  auto 1fr; gap: 2px; align-items: left;">
                <span>Buffer:</span>
                <span id="bufferSeconds"></span>
                <span>seconds</span>
                <span></span>

                <span>Delay:</span>
                <span>
                <input type="range" id="delaySlider" min="0" max="20" value="3" step="0.5"
                    oninput="document.getElementById('delayValue').innerText=this.value;"
                    onchange="form_updated()">
                    </span>
                <span><span id="delayValue">3</span> seconds</span>
                <span></span>

                <span>Reply buffer:</span>
                <span>
                    <input type="range" id="replyBufferSlider" min="0" max="20" value="10" step="0.5"
                    oninput="document.getElementById('replyBufferValue').innerText=this.value;"
                    onchange="form_updated()">
                    </span>
                <span><span id="replyBufferValue">10</span> seconds</span>
                <span></span>
            </div>
            Resize:
            <button onclick="window.location.href='?width=320'">Tiny</button>
            <button onclick="window.location.href='?width=640'">Small</button>
            <button onclick="window.location.href='?width=800'">Medium</button>
            <button onclick="window.location.href='?width=1024'">Large</button>
            <button onclick="window.location.href='?width=1280'">Very large</button>
            <br/>
            <select id="videoSource" onchange="form_updated()"></select>
        </div>
        <span>
            <button id="replaybutton" onclick="replay()">Replay</button>
            <button id="pausebutton" onclick="togglePause()">Pause</button>
        </span>
        <div style="position: relative;">
            <span id="timediff" style="position: absolute; top: 0; left: 0;"></span>
            <img id="videoElement" style="display: block;" />
        </div>
    </div>
    <script>
        const hiddenVideo = document.createElement('video');
        var video = document.querySelector("#videoElement");

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const delayedVideo = document.createElement('video');
        const mediaRecorder_chunks = [];
        let mediaRecorder;

        const frameBuffer = [];

        let replay_end_time = 0;
        let replay_offset = 0;

        function restart_stream() {
            frameBuffer.length = 0; // Clear frame buffer
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                const videoSelect = document.querySelector('select#videoSource');
                const videoSource = videoSelect.value;
                const constraints = {
                    video: { deviceId: videoSource ? { exact: videoSource } : undefined }
                };

                navigator.mediaDevices.getUserMedia(constraints)
                    .then(function (stream) {
                        hiddenVideo.style.display = 'none';
                        hiddenVideo.srcObject = stream;
                        hiddenVideo.play();

                        // Set canvas size based on URL parameter or default
                        const urlParams = new URLSearchParams(window.location.search);
                        const widthParam = urlParams.get('width');
                        if (widthParam) {
                            canvas.width = parseInt(widthParam);
                        } else {
                            canvas.width = 800;
                        }
                        canvas.height = (canvas.width * 600) / 800;

                        // Add this row if you want to see the current captured frames
                        //video.parentNode.appendChild(canvas);

                        function captureFrame() {
                            const timestamp = Date.now();
                            ctx.drawImage(hiddenVideo, 0, 0, canvas.width, canvas.height);

                            // Push frame to buffer
                            const imageData = canvas.toDataURL('image/png');
                            frameBuffer.push({ timestamp, imageData });

                            // Find the delayed frame to display
                            let delayedFrame = null;

                            if (replay_end_time > 0) {
                                // We are in replay mode when replay_end_time is set

                                // Delete old frames and find next frame to display
                                while (frameBuffer.length > 0 && frameBuffer[0].timestamp < timestamp + replay_offset) {
                                    delayedFrame = frameBuffer.shift();
                                }

                                // Determine if we reached the end of the replay
                                if (delayedFrame && delayedFrame.timestamp >= replay_end_time) {
                                    replay_end_time = 0;
                                    document.getElementById('replaybutton').disabled = false;
                                }
                            } else {
                                // Normal live delay mode

                                var replyBufferSeconds = parseFloat(document.getElementById('replyBufferSlider').value);
                                var delaySeconds = parseFloat(document.getElementById('delaySlider').value);

                                // Remove old frames beyond the reply buffer
                                const cutoffTimestamp = timestamp - replyBufferSeconds * 1000 - delaySeconds * 1000;
                                while (frameBuffer.length > 0 && frameBuffer[0].timestamp < cutoffTimestamp) {
                                    frameBuffer.shift();
                                }

                                // Find first frame that matches the delay
                                const delayedTimestamp = timestamp - delaySeconds * 1000;
                                delayedFrame = frameBuffer.find(frame => frame.timestamp >= delayedTimestamp);
                            }

                            // Update buffer count display
                            if (frameBuffer.length > 0) {
                                let firstTimestamp = frameBuffer[0].timestamp;
                                let lastTimestamp = frameBuffer[frameBuffer.length - 1].timestamp;
                                document.getElementById('bufferSeconds').innerText = ((lastTimestamp - firstTimestamp) / 1000).toFixed(1);
                            }

                            // Display the delayed frame if found
                            if (delayedFrame) {
                                var video = document.querySelector("#videoElement");
                                const img = new Image();
                                img.src = delayedFrame.imageData;

                                // Display time difference
                                let difftext = '';
                                if (replay_end_time > 0) {
                                    let timediff = delayedFrame.timestamp - replay_end_time;
                                    difftext = (-timediff / 1000).toFixed(1) + ' replay';
                                } else {
                                    let timediff = delayedFrame.timestamp - timestamp;
                                    difftext = (-timediff / 1000).toFixed(1) + ' seconds ago';
                                }
                                document.getElementById('timediff').innerText = difftext;

                                // Show the frame
                                video.style.display = 'block';
                                video.src = delayedFrame.imageData;
                            }

                            // Schedule next frame capture if not paused
                            if (!isPaused)
                                requestAnimationFrame(captureFrame);
                        }

                        // Start capturing frames when the hidden video is playing
                        hiddenVideo.addEventListener('playing', function () {
                            captureFrame();
                        });
                    })
                    .catch(function (err0r) {
                        console.log("Something went wrong!");
                    });
            }

            // Add event listener to restart stream when video source changes
            document.querySelector('select#videoSource').addEventListener('change', function () {
                if (hiddenVideo.srcObject) {
                    hiddenVideo.srcObject.getTracks().forEach(track => track.stop());
                }
                restart_stream();
            });
        }

        // Pause/Resume function
        var isPaused = false;
        function togglePause() {
            isPaused = !isPaused;
            var pauseButton = document.getElementById('pausebutton');
            if (isPaused) {
                pauseButton.innerText = 'Resume';
                hiddenVideo.pause();
                setTimeout(() => {
                    document.getElementById('timediff').innerText = "Paused";
                }, 100);
            } else {
                pauseButton.innerText = 'Pause';
                hiddenVideo.play();
            }
        }

        // Replay function
        function replay() {
            var delaySeconds = parseFloat(document.getElementById('delaySlider').value);

            // Set replay to end at current shown time
            replay_end_time = Date.now() - delaySeconds * 1000;

            // Offset of replay is from the first frame in buffer
            replay_offset = frameBuffer[0].timestamp - replay_end_time - delaySeconds * 1000;

            document.getElementById('replaybutton').disabled = true;
        }

        // Cache form values in localStorage
        function form_updated() {
            const delayValue = document.getElementById('delaySlider').value;
            const replyBufferValue = document.getElementById('replyBufferSlider').value;
            const videoSourceValue = document.getElementById('videoSource').value;

            localStorage.setItem('delaySlider', delayValue);
            localStorage.setItem('replyBufferSlider', replyBufferValue);
            localStorage.setItem('videoSource', videoSourceValue);
        }

        // Load form values from localStorage
        function load_form_values() {
            const delayValue = localStorage.getItem('delaySlider');
            const replyBufferValue = localStorage.getItem('replyBufferSlider');
            const videoSourceValue = localStorage.getItem('videoSource');

            if (delayValue !== null) {
                document.getElementById('delaySlider').value = delayValue;
                document.getElementById('delayValue').innerText = delayValue;
            }
            if (replyBufferValue !== null) {
                document.getElementById('replyBufferSlider').value = replyBufferValue;
                document.getElementById('replyBufferValue').innerText = replyBufferValue;
            }
            if (videoSourceValue !== null) {
                document.getElementById('videoSource').value = videoSourceValue;
            }
        }

        // Find all available video input devices and populate the select dropdown
        function find_video_devices(callback) {
            navigator.mediaDevices.enumerateDevices().then(function (devices) {
                for (var i = 0; i < devices.length; i++) {
                    var device = devices[i];
                    if (device.kind === 'videoinput') {
                        var option = document.createElement('option');
                        option.value = device.deviceId;
                        option.text = device.label || 'camera ' + (i + 1);
                        document.querySelector('select#videoSource').appendChild(option);
                    }
                };
                callback();
            });
        }

        // Toggle fullscreen function
        function toggleFullscreen() {
            const container = document.getElementById('container');
            const fullscreenButton = document.getElementById('fullscreenbutton');
            
            if (!container.classList.contains('fullscreen')) {
                // Enter fullscreen
                container.classList.add('fullscreen');
                fullscreenButton.innerText = 'Exit Fullscreen';
            } else {
                // Exit fullscreen
                container.classList.remove('fullscreen');
                fullscreenButton.innerText = 'Fullscreen';
            }
        }

        // Called on body-load
        function init() {
            find_video_devices(() => {
                load_form_values();
                restart_stream();
            });
        }
    </script>
</body>
</html>